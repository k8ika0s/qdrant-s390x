# s390x (IBM Z / zLinux) Support

This repository contains ongoing work to make Qdrant build, test, and run on `s390x` (big-endian).

## Compatibility Goals

- Build from source on `s390x-unknown-linux-gnu`.
- Run the core service (`qdrant`) with RocksDB enabled.
- Keep persisted formats architecture-neutral (see `docs/PERSISTENCE_ENDIANNESS.md`).
- Provide regression coverage that prevents reintroducing endian-dependent persistence.

## CI Signals

Current CI provides two informational s390x lanes:

- `s390x check`: `cargo check -p qdrant --target s390x-unknown-linux-gnu`
- `s390x unit tests (qemu)`: runs a curated set of tests under `cross` + QEMU, including a
  snapshot fixture round-trip to exercise LE<->BE portability at a high level

These jobs are intentionally `continue-on-error` while the signal is being stabilized.

## Release Artifacts and Images

This repository includes the plumbing to produce s390x deliverables without changing existing
amd64/arm64 consumers:

- GitHub Releases: `s390x-unknown-linux-gnu` is included in `.github/workflows/release-artifacts.yml`
  (currently `continue-on-error` while the lane is stabilized).
- Container images: `.github/workflows/docker-image.yml` builds and publishes multi-arch images that
  include `linux/s390x` alongside `linux/amd64` and `linux/arm64`.

### Promotion Criteria (Informational -> Required)

Suggested promotion criteria (to keep review friction low while avoiding “forever-informational”):

- Phase 0 (today): `continue-on-error` while we harden the lane and eliminate flakes.
- Phase 1: make `s390x check` required (fast compile signal; should be stable).
- Phase 2: make `s390x unit tests (qemu)` required once:
  - the curated test set stays green on the default branch for a sustained period, and
  - job runtime is within an acceptable envelope for normal PR cadence, and
  - failures are actionable (not infra noise).

### Known Limitations

- The QEMU lane intentionally runs a small “high-signal” subset. It is not expected to cover the full
  `segment` test suite or any long-running end-to-end scenarios.
- Qdrant's `api` crate generates gRPC bindings at build time. `Cross.toml` installs `protoc` into the
  s390x cross image so the QEMU lane can build and run `qdrant` integration tests when needed.
- Native s390x hosts remain the source of truth for final validation before declaring a change
  “s390x-ready” (see the native gate sweep below).
- Runtime budget (guideline):
  - `s390x check`: keep it “quick” (single-digit minutes on GitHub runners).
  - `s390x unit tests (qemu)`: keep it bounded (avoid adding broad workspace tests; prefer targeted
    filters like `segment endian` and the routing determinism test).

## Native Validation Gates

For native hosts (recommended for final validation), use:

```bash
tools/run-s390x-gates.sh
```

This writes per-stage logs under `dev-docs/s390x-validation/` by default.

### Container Smoke (Optional)

On native hosts with `podman` or `docker`, you can also run a container runtime smoke:

```bash
S390X_CONTAINER_SMOKE=1 tools/run-s390x-gates.sh
```

Or run it directly:

```bash
tools/s390x-container-smoke.sh
```

Notes:

- This validates that a container image packaging a **native** `qdrant` binary boots and serves HTTP,
  and that persisted data survives a container restart.
- It does not exercise the multi-arch `docker buildx` pipeline (which builds `linux/s390x` images on
  `linux/amd64` runners via cross-compilation).

### “s390x-ready” Gate Conditions

We consider a change “s390x-ready” when the following are true:

- `cargo check -p qdrant --target s390x-unknown-linux-gnu --locked` succeeds (CI `s390x check` lane).
- The curated QEMU test slice stays green (CI `s390x unit tests (qemu)` lane).
- A native s390x host run of `tools/run-s390x-gates.sh` completes with `rc=0` for all stages.

For changes that touch persistence formats, also require:

- Explicit endian-safe persistence (see `docs/PERSISTENCE_ENDIANNESS.md`) plus targeted regression tests.
- At least one negative test that rejects malformed/truncated input for any new/modified decode path.

### Performance Smoke Benches (Optional)

For persistence-heavy changes, run lightweight Criterion benches on both LE and BE hosts to
capture reference timing snapshots.

Unified suite (recommended):

```bash
tools/s390x-perf-smoke.sh
```

Or as part of the native gate sweep:

```bash
S390X_PERF_SMOKE=1 tools/run-s390x-gates.sh
```

Quantization persistence smoke (encode + score):

```bash
QDRANT_QBENCH_VECTORS=4096 \
QDRANT_QBENCH_DIM=64 \
QDRANT_QBENCH_SAMPLE_SIZE=10 \
QDRANT_QBENCH_WARMUP_SECS=1 \
QDRANT_QBENCH_MEASUREMENT_SECS=2 \
cargo bench -p quantization --bench persistence_smoke -- --nocapture
```

Sparse mmap build/convert smoke:

```bash
cargo bench -p segment --features rocksdb --bench sparse_index_build \
  -- --warm-up-time 1 --measurement-time 2 --sample-size 10
```

Suggested workflow:

- Save raw bench output under `dev-docs/s390x-validation/` with architecture-tagged filenames.
- Compare against prior runs on the **same architecture/host class**.
- Treat changes within benchmark noise as acceptable; investigate sustained regressions.

### Performance Threshold Policy

Use these initial thresholds as merge-gate heuristics when comparing against the most recent
baseline for the same host class/profile:

- HNSW persistence smoke (build + search medians): investigate if sustained regression is `>15%`.
- Sparse index build/convert medians: investigate if sustained regression is `>15%`.
- Quantization persistence smoke (encode + score medians): investigate if sustained regression is `>20%`.
- Startup latency (boot1/boot2 ready time): investigate if sustained regression is `>20%`.
- Memory footprint (`rss_after_workload_kb` in perf smoke): investigate if sustained regression is `>15%`.

If a threshold is exceeded, require one of:
- a fix before merge,
- a documented exception with rationale and a follow-up issue,
- or subsystem owner sign-off that tradeoff is expected and acceptable.

### Observability Hooks

Runtime telemetry now includes architecture and persistence compatibility context:

- `system.arch`
- `system.cpu_endian`
- `system.persistence_compat.format_versions`
- `system.persistence_compat.migration_counters`

Operator diagnostics:

- Legacy HNSW GraphLinks fallback decode paths emit explicit warnings.
- Legacy fallback/migration counts are exposed via telemetry counters to support post-upgrade audits.

### Cross-Endian Snapshot Fixtures (Optional, High Signal)

For deeper portability validation (LE -> BE and BE -> LE), use the ignored fixture tests:

- Producer (run on the source architecture, writes a fixture directory):
  ```bash
  S390X_FIXTURES_DIR=dev-docs/s390x-fixtures/le-run \
    cargo test -p qdrant --features rocksdb --locked --test s390x_snapshot_fixture_matrix \
    -- --ignored s390x_snapshot_fixture_produce
  ```
- Copy the resulting directory to the other architecture.
- Consumer (run on the target architecture, restores and validates all fixtures in the directory):
  ```bash
  S390X_FIXTURES_DIR=/path/to/copied/fixtures \
    cargo test -p qdrant --features rocksdb --locked --test s390x_snapshot_fixture_matrix \
    -- --ignored s390x_snapshot_fixture_consume
  ```

If `S390X_FIXTURES_DIR` is set, `tools/run-s390x-gates.sh` will also run the consumer as part of the
native gate sweep.

Notes:

- Some stages are link- and disk-heavy. On shared/limited hosts, consider `CARGO_BUILD_JOBS=2` and
  ensure sufficient free disk space before running full workspace builds/tests.
- The gate sweep includes an ignored end-to-end HTTP smoke test (`tests/s390x_http_smoke.rs`) that:
  - boots Qdrant,
  - creates a collection and upserts points,
  - restarts Qdrant and re-queries persisted data.
  You can run it directly with:
  ```bash
  cargo test -p qdrant --features rocksdb --locked --test s390x_http_smoke -- --ignored
  ```
- The gate sweep also includes an ignored snapshot create/restore test (`tests/s390x_snapshot_smoke.rs`)
  that creates a collection snapshot and restores it into a fresh storage path:
  ```bash
  cargo test -p qdrant --features rocksdb --locked --test s390x_snapshot_smoke -- --ignored
  ```

## Persistence Hygiene

When touching a persisted on-disk format:

1. Follow `docs/PERSISTENCE_ENDIANNESS.md` (canonical little-endian persistence).
2. Add or bump a version marker where practical.
3. Add migration/compatibility tests (including malformed-input tests).
4. Optionally run:

```bash
tools/check-persistence-endianness.sh <touched-file>...
```

This is a heuristic helper intended to catch obvious mistakes early.

## Cluster Routing and Mixed-Endian Notes

Cluster routing is based on a stable hashing layer (`common::stable_hash`) which encodes numeric
types in canonical **little-endian** form before hashing. This ensures shard routing decisions are
architecture-independent and enables mixed-endian clusters (LE + BE) in principle.

Operational guidance:

- For safety, treat mixed-endian clusters as supported only when **all nodes run a build that
  includes the stable-hash canonicalization work**.
- If you need to validate routing stability, run the `collection` crate test:
  `cargo test -p collection test_routing_is_stable_across_architectures`.

## Known Tradeoffs and Tuning Hints

- Legacy compatibility decode paths may add startup cost on first load of old segment files.
  Once data is rewritten in canonical format, repeated fallback decode should drop.
- Compare perf only within the same host class and profile (`debug` vs `release`), not across
  unrelated hardware.
- Prefer `release` builds for service latency profiling and production-like measurements.
- On constrained hosts, set `CARGO_BUILD_JOBS` to avoid memory pressure during native validation
  builds.
- For runtime tuning, keep `max_search_threads` aligned with available cores and workload shape;
  over-provisioning can increase contention on smaller hosts.

## Architecture FAQ

### Is s390x support expected to change behavior on x86_64/aarch64?

No. The compatibility work is scoped to preserve existing LE behavior and only add explicit-endian
decode/encode boundaries where persisted formats previously depended on native endianness.

### Are old persisted files still readable?

Where feasible, readers include compatibility paths for legacy layouts; new writes use canonical
little-endian encodings. See `docs/PERSISTENCE_ENDIANNESS.md` and feature-specific tests for
legacy fixture coverage.

### Do I need mixed-endian clusters to use s390x?

No. Single-architecture clusters remain valid. Mixed-endian operation should only be used once all
nodes run builds with the stable-hash and persistence-compatibility work included.

## Subsystem Migration Map

- Stable routing/hash:
  - Contract: architecture-independent hash input encoding.
  - Rollback: keep homogeneous-architecture cluster while rolling back.
- Sparse mmap indexes:
  - Contract: canonical little-endian persisted bytes with versioned index directories.
  - Rollback: restore snapshot/index files created by previous compatible build.
- Dense/chunked mmap vectors:
  - Contract: fixed-width metadata and canonical persisted payload encoding.
  - Rollback: restore segment snapshot from pre-migration build.
- HNSW graph links:
  - Contract: versioned headers with legacy compatibility readers.
  - Rollback: keep legacy graph files and reopen with compatible build.
- Quantization files:
  - Contract: v2 canonical little-endian metadata with dual-reader support for legacy.
  - Rollback: reopen with build that still supports both legacy and canonical versions.
